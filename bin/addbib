#!perl

=begin metadata

Name: addbib
Description: create or extend a bibliographic database
Author: brian d foy
License: artistic2

=end metadata

=cut

package PerlPowerTools::addbib;

use strict;
use warnings;
use vars qw($opt_a $opt_p);

use constant ABSTRACT              => 'Abstract';
use constant STOP_ON_NEWLINE       => 0;
use constant KEEP_GOING_ON_NEWLINE => 1;

use constant EX_SUCCESS => 0;
use constant EX_FAILURE => 1;
use constant EX_USAGE   => 2;

use constant CONTROL_C => chr(3);
use constant CONTROL_D => chr(4);
use constant BACKSPACE => chr(8);
use constant LINEFEED  => chr(hex('0A'));
use constant CARRIAGE  => chr(hex('0D'));
use constant SPACE     => chr(hex('20'));
use constant BACKSLASH => chr(hex('5C'));
use constant DELETE    => chr(hex('7F'));

END { eval q( Term::ReadKey::ReadMode('restore') ) }
$SIG{'INT'}  = sub { exit( 128 + get_signal_number('INT')  ) };
$SIG{'TERM'} = sub { exit( 128 + get_signal_number('TERM') ) };

exit( __PACKAGE__->run(@ARGV) ) unless caller();

sub run {
	my( $class, @args ) = @_;
	return EX_FAILURE unless $class->setup_terminal;
	my $database_file = $class->process_options(@args);
	unless( defined $database_file ) {
		$class->usage();
		return EX_USAGE;
		}

	my $db_fh = $class->open_db($database_file);
	unless( defined $db_fh ) {
		$class->error( "Could not open <$database_file>: $!\n" );
		return EX_FAILURE;
		}

	my @Prompts = $class->default_prompts();
	if( $opt_p ) {
		@Prompts = ();
		open my $fh, '<', $opt_p or do {
			$class->error( "can't read $opt_p: $!" );
			return EX_FAILURE;
			};
		while (<$fh>) {
			push @Prompts, [ $1, $2 ] if /^\s*([^%]+)\t(%\w)/;
			}
		}

	my $answer = $class->prompt( 'Instructions?', 'n', STOP_ON_NEWLINE );
	$class->output_instructions if $answer =~ /^y/i;

	RECORD: while (1) {
		print {$db_fh} "\n";		# start a new entry

		my $lines = $class->get_record(@Prompts);
		print {$db_fh} join '', @$lines;

		CONTINUE: {
			my $answer = $class->prompt( 'Continue?', 'y', STOP_ON_NEWLINE );
			last RECORD if $answer =~ m/\A[nq]/i;

			if( $answer =~ /^\s*(ed|edit|ex|vi|view|emacs)\s*/ ) {
				my $editor = $1;
				close $db_fh or do {
					$class->error( "can't close $database_file: $!\n" );
					return EX_FAILURE;
					};
				unless( 0 == system $editor, $database_file ) {
					$class->error( "'$1 $database_file' failed: $?\n" );
					return EX_FAILURE;
					}
				$db_fh = $class->open_db($database_file);
				redo CONTINUE;
				}
			}
		}

	return EX_SUCCESS;
	}

sub default_prompts {
	(
	[ 'Author name', '%A' ],
	[ 'Title',       '%T' ],
  	[ 'Journal',     '%J' ],
  	[ 'Volume',      '%V' ],
  	[ 'Pages',       '%P' ],
  	[ 'Publisher',   '%I' ],
  	[ 'City',        '%C' ],
  	[ 'Date',        '%D' ],
  	[ 'Other',       '%O' ],
  	[ 'Keywords',    '%K' ],
  	[ ABSTRACT,      '%X' ],
	);
	}

sub error {
	my $class = shift;
	print {$class->error_fh} @_;
	}

sub error_fh { \*STDERR }

sub get_line {
	my( $class, $keep_going_on_newline ) = @_;
	$keep_going_on_newline = defined $keep_going_on_newline ? $keep_going_on_newline : STOP_ON_NEWLINE;

	my $line = '';

	CHAR: while(1) {
		my $c = ReadKey(0);
		if( ! defined $c ) {
			select undef, undef, undef, 0.01;
			next CHAR;
			}

		if( $c eq CONTROL_C ) {
			print "\n";
			exit( 128 + 2 );
			}
		elsif( $c eq CONTROL_D ) { # Control-D
			print "^D\n";
			last CHAR;
			}
		elsif( $c eq BACKSPACE or $c eq DELETE ) {
			next CHAR if length($line) == 0;
			chop $line;
			print BACKSPACE, SPACE, BACKSPACE; # back up, overwrite, back up
			}
		elsif( $c eq CARRIAGE ) {
			my $n = ReadKey(0);
			if( $n eq LINEFEED ) {
				$line .= CARRIAGE . LINEFEED;
				print CARRIAGE . LINEFEED;
				last CHAR;
				}
			}
		elsif( $c eq LINEFEED ) {
			$line .= $c;
			print $c;
			next CHAR if $keep_going_on_newline;
			last CHAR;
			}
		elsif( $c eq BACKSLASH ) {
			print BACKSLASH;
			my $n = ReadKey(0);
			if( $n eq LINEFEED ) {
				$line .= SPACE;
				print LINEFEED . '> ';
				}
			else {
				$line .= BACKSLASH . $n;
				print $n;
				}
			}
		else {
			$line .= $c;
			print $c;
			}
		}

	return $line;
	}

sub get_record {
	my $class = shift;
	my @Prompts = @_;
	my @lines = ();

	PROMPT: for (my $i=0; $i < @Prompts; $i++)  {
		next PROMPT if( $opt_a and $Prompts[$i][0] eq ABSTRACT );

		local $_ = $class->prompt( $
			Prompts[$i][0],
			undef,
			$Prompts[$i][0] eq ABSTRACT ? KEEP_GOING_ON_NEWLINE : STOP_ON_NEWLINE
			);
		$_ = defined $_ ? $_ : '';
		chomp($_);
		next PROMPT if /^$/;

		if( /^-$/ ) {
			$i -= 2;
			next PROMPT;
			}

		if( $Prompts[$i][0] eq ABSTRACT ) {
			s/^\s*/%X\t/mg;
			push @lines, "$_\n";
			}
		else {
			push @lines, "$Prompts[$i][1]\t$_\n";
			}
		}

	return \@lines;
	}

sub get_signal_number {
	require Config;
    my( $sig_name ) = @_;
    my %sig_num;

	my @arrays =
		map  { split /\s+/, $Config::Config{$_} }
		grep { exists $Config::Config{$_} }
		qw(sig_name sig_num);

	return 0 unless @arrays == 2;
	return 0 unless @{ $arrays[0] } == @{ $arrays[1] };

	my %sig_hash = map { uc($arrays[0][$_]), $arrays[1][$_] } 0 .. $#{ $arrays[0] };

	exists $sig_hash{uc($sig_name)} ? $sig_hash{uc($sig_name)} : 0;
	}

sub open_db {
	my( $class, $file ) = @_;
	open my $fh, '>>', $file or return;
	return $fh;
	}

sub output {
	my $class = shift;
	print {$class->output_fh} @_;
	}

sub output_fh { \*STDOUT }

sub output_instructions {
	$_[0]->output( <<_EOINST );
	addbib will prompt you for various bibliographic fields.
	If you don't need a particular field, just hit RETURN,
		and that field will not appear in the output file.
	If you want to return to previous fields in the skeleton,
		a single minus sign will go back a field at a time.
		(This is the best way to input multiple authors.)
	If you have to continue a field or add an unusual field,
		a trailing backslash will allow a temporary escape.
	Finally, (without -a) you will be prompted for an abstract.
	Type in as many lines as you need, and end with a ctrl-d.
	To quit, type `q' or `n' when asked if you want to continue.
	To edit the database, type `edit', `vi', or `ex' instead.

_EOINST
	}

sub process_options {
	require Getopt::Std;
	my $class = shift;

	local @ARGV = @_;
	{
	local $SIG{__WARN__} = sub { 1 };
	Getopt::Std::getopts( 'ap:');
	}

	return $ARGV[0];
	}

sub prompt {
	my( $class, $prompt, $default, $is_abstract ) = @_;

	$class->output(
		$prompt,
		(defined $default ? " [$default]" : '' ),
		': '
		);

	chomp( my $answer = $class->get_line($is_abstract) );
	$answer = $default if $answer =~ /^$/;
	no warnings;
	return $answer;
	}

sub setup_terminal {
	my $class = shift;
	my $has_term_readkey = eval { require Term::ReadKey };
	unless( $has_term_readkey ) {
		$class->error( "The Perl version of addbib ($0) needs the Term::ReadKey module\n\n$@" );
		return;
		}

	Term::ReadKey->import;
	ReadMode('raw');
	$|++;
	return 1;
	}

sub usage {
	require File::Basename;
	$_[0]->output(
		sprintf "usage: %s [ -a ] [ -p promptfile ] database\n", File::Basename::basename($0)
		);
	exit 2;
	}

__END__

=head1 NAME

addbib - create or extend a bibliographic database

=head1 SYNOPSIS

    addbib [ -a ] [ -p promptfile ] database

=head1 DESCRIPTION

When addbib starts up, answering y to the initial Instructions? prompt
yields directions. Typing n (or RETURN) skips the directions. addbib
then prompts for various bibliographic fields, reads responses from
the terminal, and sends output records to database. A null response
(just RETURN) means to leave out that field. A C<-> (minus sign) means
to go back to the previous field. A trailing backslash allows a field
to be continued on the next line. The repeating Continue? prompt
allows the user either to resume by typing y (or RETURN), to quit the
current session by typing n or q, or to edit database with any system
editor (see vi(1), ex(1), ed(1)).

=head2 Options

=over 4

=item -a

Suppresses prompting for an abstract. Asking for an abstract is the
default. Abstracts are ended with a Control-D.

=item -p promptfile

Uses a new prompting skeleton, defined in promptfile. This file should
contain prompt strings, a TAB, and the key-letters to be written to
the database.

=back

=head2 Usage

=head3 Bibliography Key Letters

The most common key-letters and their meanings are given below. addbib
insulates you from these key-letters, since it gives you prompts in
English, but if you edit the bibliography file later on, you will need
to know this information.

=over 4

=item %A	 Author's name

=item %B	 Book containing article referenced

=item %C	 City (place of publication)

=item %D	 Date of publication

=item %E	 Editor of book containing article referenced

=item %F	 Footnote number or label (supplied by refer)

=item %G	 Government order number

=item %H	 Header commentary, printed before reference

=item %I	 Issuer (publisher)

=item %J	 Journal containing article

=item %K	 Keywords to use in locating reference

=item %L	 Label field used by -k option of refer

=item %M	 Bell Labs Memorandum (undefined)

=item %N	 Number within volume

=item %O	 Other commentary, printed at end of reference

=item %P	 Page number(s)

=item %Q	 Corporate or Foreign Author (unreversed)

=item %R	 Report, paper, or thesis (unpublished)

=item %S	 Series title

=item %T	 Title of article or book

=item %V	 Volume number

=item %X	 Abstract - used by roffbib, not by refer

=item %Y,Z   Ignored by	refer

=back

=head3 Examples

Example 1 Editing the bibliography file.

Except for A, each field should be given just once. Only relevant fields should be supplied.

	%A	Mark Twain
	%T	Life on the Mississippi
	%I	Penguin Books
	%C	New York
	%D	1978

=head1 AUTHOR

Documentation is taken from the FreeBSD man page and adapted for Pod.

A previous version of this program was written by Jeffrey S. Haemer. It was
completely replaced by brian d foy to properly handle Control-D by using raw
terminal interactions.

=head1 SOURCE AVAILABILITY

This file is part of the PerlPowerTools project:

	https://github.com/briandfoy/PerlPowerTools/

=head1 COPYRIGHT and LICENSE

This program is Copyright E<copy> 2026-2026, brian d foy

This program is licensed under the Artistic License 2.0. You can use
and modify this program under the terms of the GNU Public License
version 2. A copy of this license is in the PerlPowerTools repository:

=cut
