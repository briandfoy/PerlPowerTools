#!/usr/bin/perl

=begin metadata

Name: shar
Description: create a shell archive of files
Author: Rich Salz, salzr@certo.com, rsalz@osf.org, rsalz@bbn.com
License: public domain

=end metadata

=cut


# public domain code by salzr@certo.com
# (formerly rsalz@osf.org, rsalz@bbn.com, mirror!rs)

use strict;

use File::Basename qw(basename);
use Getopt::Std qw(getopts);

use constant EX_SUCCESS => 0;
use constant EX_FAILURE => 1;

my $Program = basename($0);

sub usage {
    warn "usage: $Program file...\n";
    exit EX_FAILURE;
}

getopts('') or usage();
binmode STDOUT;

# Do work.
my $dirty = 0;
ARGUMENT: for my $f ( @ARGV ) {
    if ( ! open(FH, '<', $f) ) {
	warn "$Program: can't open '$f': $!\n";
	next ARGUMENT;
    }
    binmode FH;

    if ( $dirty++ == 0 ) {
	print '# --cut here--
#! /bin/sh
# To unshar, remove everything before the "cut here" line
# and feed the result to /bin/sh
'
    }
    if (-B $f) {
	my $mode = (stat $f)[2];
	$mode = (join '', 0, ($mode&0700)>>6, ($mode&0070)>>3, ($mode&0007));
	print "sed -e 's/^X//' | uudecode <<'FUNKY_STUFF'\n";
	print "begin $mode $f\n";
	my $block;
	print pack 'u', $block while read FH, $block, 45;
	print "end\n";
	print "FUNKY_STUFF\n";
    } else {
	print "sed -e 's/^X//' >$f <<'FUNKY_STUFF'\n";
	print 'X', $_ while ( <FH> );
	print "FUNKY_STUFF\n";
    }
    close(FH);
}

unless ($dirty) {
    warn "$Program: no input files were processed\n";
    exit EX_FAILURE;
}
exit EX_SUCCESS;

__END__

=head1 NAME

shar - create a shell archive of files

=head1 SYNOPSIS

B<shar> file...

=head1 DESCRIPTION

B<shar> creates a shell archive of the I<files> on the command line. The shell
archive is a shell script, and executing it will recreate the I<files>.
Directories are I<not> recreated.

=head1 SEE ALSO

B<unshar>

=head1 AUTHOR

Rich Salz | salzr@certo.com | rsalz@osf.org | rsalz@bbn.com

=head1 COPYRIGHT

This code is released to the public domain.

=cut
