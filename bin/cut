#!/usr/bin/perl

=begin metadata

Name: cut
Description: select portions of each line of a file
Author: Rich Lafferty, rich@alcor.concordia.ca
License: perl

=end metadata

=cut


#
# cut -- remove sections from each line of files
#
#        Rich Lafferty <rich@alcor.concordia.ca>
#        Thu Mar  4 02:33:30 EST 1999
#
#   Perl Power Tools -- http://language.perl.com/ppt/
#

use strict;

use File::Basename qw(basename);
use Getopt::Std qw(getopts);

use constant EX_SUCCESS => 0;
use constant EX_FAILURE => 1;

my $me = basename($0);

sub usage {
    print <<EOT;
usage:  $me -b list [-n] [file ...]
        $me -c list [file ...]
        $me -f list [-d delim] [-s] [file ...]

Each LIST is made up of one range, or many ranges separated by commas.
Each range is one of:

  N     Nth byte, character or field, counted from 1
  N-    from Nth byte, character or field, to end of line
  N-M   from Nth to Mth (included) byte, character or field
  -M    from first to Mth (included) byte, character or field

EOT
    exit EX_FAILURE;
}

sub checknum {
    my $n = shift;
    if ($n !~ m/\A\-?[0-9]+\Z/) {
	warn "$me: unexpected byte or field number: '$n'\n";
	exit EX_FAILURE;
    }
    if ($n == 0) {
	warn "$me: bytes and fields are numbered from 1\n";
	exit EX_FAILURE;
    }
}

my %opt;
getopts('b:c:d:f:ns', \%opt) or usage();

# There's no difference between -b and -c on any unix I
# use regularly -- it's for i18n. Thus, -n is a noop, too.
$opt{b} = $opt{c} if defined $opt{c};

## Byte operations
if (defined ($opt{b})) {

    my @list = split (/,/, $opt{b});

    while (<>) {
	chomp;

	foreach my $item (@list) {
	    my ($start, $end);
	    if (substr($item, 0, 1) eq '-') {
		checknum($item);
		$start = 1;
		$end = abs($item) + 1;
	    } elsif (index($item, '-') == -1) {
		checknum($item);
		$start = $item;
		$end = $start + 1;
	    } else {
		($start, $end) = split /\-/, $item;
		checknum($start);
		checknum($end);
		$end++;
		if ($start >= $end) {
		    warn "$me: invalid byte list\n";
		    exit EX_FAILURE;
		}
	    }

	    # change cut's list parameters to substr's parameters
	    $start = length if $start > length;
	    $end = length if $end > length;

	    printf "%s", substr($_, $start - 1, $end - $start);
	}
	print "\n";
    }
    exit EX_SUCCESS;
}

## Field operations
elsif (defined ($opt{f})) {

    my @list = split (/,/, $opt{f});
    my $delim = "\t";
    $delim = substr ($opt{d}, 0, 1) if defined $opt{d};

    while (<>) {
	chomp;

	# Only waste time on lines with delimiters
	if (/$delim/) {
	    foreach my $item (@list) {
		my ($start, $end);
		if (substr($item, 0, 1) eq '-') {
		    checknum($item);
		    $start = 0;
		    $end = abs $item;
		} elsif (index($item, '-') == -1) {
		    checknum($item);
		    $start = $item - 1;
		    $end = $start + 1;
		} else {
		    ($start, $end) = split /\-/, $item;
		    checknum($start);
		    checknum($end);
		    $start--;
		    if ($start >= $end) {
			warn "$me: invalid field list\n";
			exit EX_FAILURE;
		    }
		}

		my @hunk = split (/$delim/, $_);

		# don't let parameters exceed number of fields
		$end = @hunk if (! $end or $end > @hunk);
		$start = @hunk if $start > @hunk;

		# If start of field is bigger than number of items, cut(1)
		# still outputs a newline -- but we won't enter the for()
		print "\n" if ($start == $end and $item eq $list[$#list]);

		for (my $i = $start; $i < $end; $i++) {
		    print $hunk[$i];
		    if ($item eq $list[$#list] and $i == $end - 1) {  # if done
			print "\n";
		    } else {
			print $delim;
		    }
		}
	    }
	} else {  # no delimiter in line
	    print "$_\n" unless $opt{"s"};
	}
    }

    exit EX_SUCCESS;
}

warn "$me: byte, character or field list required\n";
usage();

# (Thanks to Abigail for the pod template.)

__END__

=pod

=head1 NAME

cut - select portions of each line of a file

=head1 SYNOPSIS

cut C<-b> list [C<-n>] [file ...]

cut C<-c> list [file ...]

cut C<-f> list [C<-d> delim] [C<-s>] [file ...]

=head1 DESCRIPTION

The B<cut> utility selects portions of each line (as specified by I<list>)
from each I<file> (or the standard input by default), and writes them to
the standard output.  The items specified by I<list> can be in terms of
column position or in terms of fields delimited by a special
character. Column numbering starts from 1.

I<list> is a comma- or whitespace-separated set of increasing numbers
and/or number ranges.  Number ranges consist of a number, a dash
('-'), and a second number and select the fields or columns from the
first number to the second, inclusive.  Numbers or number ranges may
be preceded by a dash, which selects all fields or columns from 1 to
the first number.  Numbers or number ranges may be followed by a dash,
which selects all fields or columns from the last number to the end of
the line.  Numbers and number ranges may be repeated, overlapping, and
in any order.  It is not an error to select fields or columns not
present in the input line.

=head1 OPTIONS

B<cut> accepts the following options:

=over 4

=item -b list

The I<list> specifies byte positions.

=item -c list

The I<list> specifies character positions.

=item -d string

Use the first character of I<string> as the field delimiter character
instead of the tab character.

=item -f list

The I<list> specifies fields, delimited in the input by a single tab
character.  Output fields are separated by a single tab character.

=item -n

Do not split multi-byte characters.

=item -s

Suppresses lines with no field delimiter characters.  Unless
specified, lines with no delimiters are passed through unmodified.

=back

=head1 BUGS

B<cut> does not understand multibyte characters; the C<-c> and C<-b>
options function identically, and C<-n> does nothing.

=head1 STANDARDS

This B<cut> implementation is compatible with the I<OpenBSD>
implementation.

=head1 AUTHOR

The Perl implementation of B<cut> was written by Rich Lafferty,
I<rich@alcor.concordia.ca>.

=head1 COPYRIGHT and LICENSE

This program is free and open software. You may use, copy, modify,
distribute and sell this program (and any modified variants) in any
way you wish, provided you do not restrict others to do the same.

=cut

