#!/usr/bin/perl

=begin metadata

Name: ls
Description: list file/directory information
Author: Mark Leighton Fisher, fisherm@tce.com
License: perl

=end metadata

=cut

package PerlPowerTools::ls;

use strict;

use Config qw(%Config);
use File::Basename qw(basename);
use File::Spec::Functions;
use File::stat;
use Getopt::Std;
use File::Spec;

use constant EX_SUCCESS         => 0;
use constant EX_FAILURE         => 1;
use constant NO_GETGRGID        => ! eval { my $dummy = ""; $dummy = (getpwuid(0))[0] };
use constant SIX_MONTHS_SECONDS => 60*60*24*(365/2);

my $Program = basename($0);

sub get_columns {
	my @methods = qw(windows unix default);
	foreach my $m ( @methods ) {
		my $cols = __PACKAGE__->can($m)->();
		next unless defined $cols;
		return $cols;
		}
	}

sub windows {
	return unless $^O eq 'MSWin32';
	my @lines = `powershell -command "&{(get-host).ui.rawui.WindowSize;}"`;

	while( my $l = shift @lines ) { last if $l =~ /\A-----/ }
	return $lines[0] =~ m/\A\s*(\d+)/ ? $1 : ();
	}

sub unix {
	return if $^O eq 'MSWin32';
	my $c = do {
		if( has('tput') ) { `tput cols` }
		elsif( has('ssty') ) { `stty size  | cut -d' ' -f 2` }
		else { undef };
		};
	chomp $c;
	return $c;
	}

sub default { 80 }

sub has {
	my $program = shift;
	foreach my $dir ( split /\Q$Config{path_sep}/, $ENV{PATH} ) {
		next unless -x catfile( $dir, $program );
		return 1;
		}
	return;
	}

BEGIN {
	my @perms = qw(--- --x -w- -wx r-- r-x rw- rwx);
	my @ftype = ( '', qw(p c ? d ? b ? - ? l ? s ? ? ?) );

	sub format_mode {
		my( $class, $mode, %opts ) = @_;

		my $setids   = ($mode & 07000)>>9;
		my @permstrs = @perms[($mode&0700)>>6, ($mode&0070)>>3, $mode&0007];
		my $ftype    = $ftype[($mode & 0170000)>>12];

		if ($setids) {
			if ($setids & 01) {		# Sticky bit
				$permstrs[2] =~ s/([-x])$/$1 eq 'x' ? 't' : 'T'/e;
				}
			if ($setids & 04) {		# Setuid bit
				$permstrs[0] =~ s/([-x])$/$1 eq 'x' ? 's' : 'S'/e;
				}
			if ($setids & 02) {		# Setgid bit
				$permstrs[1] =~ s/([-x])$/$1 eq 'x' ? 's' : 'S'/e;
				}
			}

		join '', $ftype, @permstrs;
		}
	} # BEGIN

our $VERSION = '0.71';
my $WinCols;		# window columns of output


# ------ functions
sub VERSION_MESSAGE {
    print "$Program version $VERSION\n";
    my_exit( EX_SUCCESS );
}

# ------ get directory entries
sub DirEntries {
	my $Options    = shift;
	my %Attributes = ();
	my @Entries    = ();

	if (exists $Options->{'d'} || ! -d $_[0]) {
		if (-l $_[0] or -e $_[0]) {
			push @Entries, $_[0] ;
			$Attributes{$_[0]} = -l $_[0] ? lstat($_[0]) : stat($_[0]);
			push @Entries, \%Attributes;
			return @Entries;
			}
		warn "$Program: can't access '$_[0]': $!\n";
		return;
		}

	my $dh;
	unless (opendir $dh, $_[0]) {
		warn "$Program: failed to open directory '$_[0]': $!\n";
		return;
		}

	my $Name = "";		# entry name
	while ($Name = readdir($dh)) {
		next if (!exists($Options->{'a'}) && $Name =~ m/^\./o);
		push @Entries, $Name;
		my $path = File::Spec->catfile( $_[0], $Name );
		$Attributes{$Name} = -l $path ? lstat($path) : stat($path);
		}
	closedir($dh);

	# ------ return list with %Attributes ref at end
	push(@Entries, \%Attributes);
	return @Entries;
	}

# ------ format directory entry
sub EntryFormat {
	my $class = shift;
	my $Options = shift;	# ls option arguments
	my $Attributes = shift;	# entry attributes hashref
	my $Entry = shift;	# directory entry name
	my $Blocks = 0;		# block size when otherwise unknown
	my $BlockSize =		# block size in 512-byte units
	 exists($Options->{'k'}) ? 2 : 1;
	my $DateStr = "";	# time/date string
	my $Gid = -1;		# group ID number
	my $Mode = "";		# file mode
	my @Month = (		# file time month abbrev.
		"Jan",
		"Feb",
		"Mar",
		"Apr",
		"May",
		"Jun",
		"Jul",
		"Aug",
		"Sep",
		"Oct",
		"Nov",
		"Dec"
	);
	my $Time = 0;		# file time
	my $Uid = -1;		# user ID number

	if( exists $Options->{'i'} ) {
		if (defined($Attributes->{$Entry})) {
			printf("%10d ", $Attributes->{$Entry}->ino);
			}
		else {
			print "_________ ";
			}
		}

	if( exists $Options->{'s'} ) {
		if( defined $Attributes->{$Entry} ) {
			$Blocks = $Attributes->{$Entry}->blocks;
			$Blocks = 0 if $Blocks eq '';
			printf "%4d ",  $Blocks / $BlockSize + (($Blocks % $BlockSize) > 0);
			}
		else {
			print "____ ";
			}
		}

	if( ! exists $Options->{'l'} ) {
		print "$Entry\n";
		}
	else {
		if( ! defined $Attributes->{$Entry} ) {
			print <<'UNDEFSTAT';
__________ ___ ________ ________ ________ ___ __  _____
UNDEFSTAT
			}
		else {
			$Mode = $class->format_mode($Attributes->{$Entry}->mode);
			print "$Mode ";
			printf "%3d ", $Attributes->{$Entry}->nlink;

			if( exists $Options->{'n'} ) {
				printf "%-8d ", $Attributes->{$Entry}->uid;
				}
			else {
				$Uid = Getpwuid($Attributes->{$Entry}->uid);
				if( defined $Uid ) {
					printf "%-8s ", $Uid;
					}
				else {
					printf"%-8d ", $Attributes->{$Entry}->uid;
					}
				}

			if (exists($Options->{'n'})) {
				printf "%-8d ", $Attributes->{$Entry}->gid;
				}
			else {
				$Gid = Getgrgid($Attributes->{$Entry}->gid);
				if (defined($Gid)) {
					printf "%-8s ", $Gid;
					}
				else {
					printf "%-8d ", $Attributes->{$Entry}->gid;
					}
				}

			if ($Attributes->{$Entry}->mode & 0140000) {
				printf "%9d ", $Attributes->{$Entry}->size;
				}
			else {
				printf("%4x,%4x ",
				 (($Attributes->{$Entry}->dev
				  & 0xFFFF000) > 16),
				 $Attributes->{$Entry}->dev
				  & 0xFFFF);
				}

			$Time = $Attributes->{$Entry}->mtime;
			$Time = $Attributes->{$Entry}->ctime if exists $Options->{'c'};
			$Time = $Attributes->{$Entry}->atime if exists $Options->{'u'};

			my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime($Time);
			print $Month[$mon];
			printf " %2d ", $mday;

			if( start_time() - $Time <= SIX_MONTHS_SECONDS ) {
				printf "%02d:%02d", $hour, $min;
				}
			else {
				printf " %04d", $year + 1900;
				}
			}
		}

	if( -l $Entry ) {
		my $target = readlink($Entry);
		$Entry .= " -> $target";
		}
	print " $Entry\n";
	}

# ------ list directory entries, breadth-first
sub List {
	my $class = shift;
	my $Name = shift;	# directory name
	my $Options = shift;	# options/flags hashref
	my $is_dir = shift;
	my $Expand = shift;	# do 1 level of dir expansion,
				# for "ls DIRNAME"
	my $Attributes = "";	# entry attributes hashref
	my $Cols = 0;		# output columns for this List()
	my $Entry = "";		# directory entry
	my @Dirs = ();		# directories from -R and DirEntries
	my $Mask = "";		# sprintf() format/mask
	my $Maxlen = 1;		# longest string for current directory
	my $Mylen = 0;		# current entry length
	my $Path = "";		# path for subdirectories
	my $Piece = "";		# piece of entry list
	my @SortedEntries = ();	# sorted entry list
	my $Rows = 0;		# output rows for this List()
	my $Target = 0;		# target element index
	my $TotalBlocks = 0;	# total directory size in blocks
	my $elt = 0;		# element index

	# ------ get directory entries attributes
	$Attributes = pop(@_);

	# ------ precompute max entry length and total size
	foreach (@_) {
		$TotalBlocks +=
			(!defined($Attributes->{$_}) || ($Attributes->{$_}->blocks eq '')) ? 0 : $Attributes->{$_}->blocks;
		$Mylen = length($_);
		$Maxlen = $Mylen if $Mylen > $Maxlen;
		}
	$Maxlen += 1;	# account for spaces

	if( $is_dir ) {
		print "$Name:\n"  if exists $Options->{'R'};
		print "total $TotalBlocks\n" if grep { defined $Options->{$_} } qw(s i);
		}

	# ------ sort entry list
	@SortedEntries = $class->Order($Options, $Attributes, @_);

	# ------ user requested 1 entry/line, long, size, or inode
	if( grep { defined $Options->{$_} } qw(1 l s i) ) {
		for my $Entry (@SortedEntries) {
			$class->EntryFormat($Options,$Attributes, $Entry);
			}
		}
	# ------ multi-column output
	else {
		# ------ compute rows, columns, width mask
		$WinCols = $class->get_columns() unless defined $WinCols;
		$Cols    = int($WinCols / $Maxlen) || 1;
		$Rows    = int(($#_+$Cols) / $Cols);
		$Mask    = sprintf "%%-%ds ", $Maxlen;

		for ($elt = 0; $elt < $Rows * $Cols; $elt++) {
			$Target =  ($elt % $Cols) * $Rows + int(($elt / $Cols));
			$Piece = sprintf($Mask, $Target < ($#SortedEntries + 1) ? $SortedEntries[$Target] : "");
			# don't blank pad to eol of line
			$Piece =~ s/\s+$// if (($elt+1) % $Cols == 0);
			print $Piece;
			print "\n" if (($elt+1) % $Cols == 0);
			}
		print "\n" if (($elt+1) % $Cols == 0);
		}

	# ------ print blank line if -R
	print "\n" if exists $Options->{'R'};

	# ------ list subdirectories of this directory
	if( !exists($Options->{'d'}) && ($Expand || exists $Options->{'R'} )) {
		for my $Entry ($class->Order($Options, $Attributes, @_)) {
			next if ($Entry eq "." || $Entry eq "..");
			if (defined($Attributes->{$Entry}) && $Attributes->{$Entry}->mode & 0040000) {
				$Path = File::Spec->canonpath(File::Spec->catdir($Name,$Entry));
				@Dirs = $class->DirEntries($Options, $Path);
				$class->List($Path, $Options, 1, 0, @Dirs);
				}
			}
		}
	}

# ------ sort file list based on %Options
sub Order {
	my $class   = shift;
	my $Options = shift;
	my $A       = shift;	# File::stat attributes hashref
	my @Entries = @_;	    # directory entry names

	# ------ sort by size, largest first
	if( exists $Options->{'S'} ) {
		if( exists $Options->{'r'} ) {
			@Entries = sort { $A->{$a}->size <=> $A->{$b}->size } @Entries;
			}
		else {
			@Entries = sort { $A->{$b}->size <=> $A->{$a}->size } @Entries;
			}
		}
	# ------ sort by time, most recent first
	elsif( grep { exists $Options->{$_} } qw(t c u) ) {
		if( exists $Options->{'r'} ) {
			if( exists $Options->{'u'} ) {
				@Entries = sort { $A->{$a}->atime <=> $A->{$b}->atime } @Entries;
				}
			elsif( exists $Options->{'c'} ) {
				@Entries = sort { $A->{$a}->ctime <=> $A->{$b}->ctime } @Entries;
				}
			else {
				@Entries = sort { $A->{$a}->mtime <=> $A->{$b}->mtime } @Entries;
				}
			}
		else {
			if( exists $Options->{'u'} ) {
				@Entries = sort { $A->{$b}->atime <=> $A->{$a}->atime } @Entries;
				}
			elsif( exists $Options->{'c'} ) {
				@Entries = sort { $A->{$b}->ctime <=> $A->{$a}->ctime } @Entries;
				}
			else {
				@Entries = sort { $A->{$b}->mtime <=> $A->{$a}->mtime } @Entries;
				}
			}
	# ------ sort by name
		}
	elsif( ! exists $Options->{'f'} ) {
		if( exists $Options->{'r'} ) {
			@Entries = sort { $b cmp $a } @Entries;
			}
		else {
			@Entries = sort { $a cmp $b } @Entries;
			}
		}

	return @Entries;
	}

sub my_exit {
	my( $class, $code ) = @_;
	CORE::exit $code;
	}

sub Getgrgid { getgrgid($_[0]) }
sub Getpwuid { getpwuid($_[0]) }

BEGIN {
	if( NO_GETGRGID ) {
		no warnings qw(redefine);
		sub Getgrgid { ($_[0], 0) }
		sub Getpwuid { ($_[0], 0) }
		}
	}

sub output_fh { \*STDOUT }
sub output {
	my( $class, @messages ) = @_;
	print { $class->output_fh } @messages;
	}

sub process_options {
	my @args = @_;
	my $Options;

	unless (getopts('1ACFLRSTWacdfgiklmnopqrstux', $Options)) {
		warn "usage: $Program [-1RSacdfiklnrstu] [file ...]\n";
		my_exit( EX_FAILURE );
		}

	$Options->{'a'} = 1 if $Options->{'f'};
	$Options->{'1'} = 1 unless -t *STDOUT;

	return ($Options, @args);
	}

sub run {
	*{"start_time"} = do { my $time = time; sub { $time } };

	my( $class, @args ) = @_;

	my( $Options, @args ) = $class->process_options(@args);
	@args = qw(.) unless @args; # current directory if nothing else

	my $ArgCount = -1;  # file/directory argument count
	my %Attributes;     # File::stat directory entry attributes
	my @Dirs;           # directories in ARGV
	my @Files;          # non-directories in ARGV
	my $First = 1;      # first directory entry on command line

	for my $Arg (@ARGV) {
		$ArgCount++;
		$Attributes{$Arg} = -l $Arg ? lstat($Arg) : stat($Arg);
		my $ref = ( -d $Arg and ! exists $Options->{'d'} ) ? \@Dirs : \@Files;
		push @$ref, $Arg;
		}

	if (@Files) {
		$First = 0;
		my %attrs;
		my @okfiles;
		foreach (@Files) {
			my @ret = $class->DirEntries($Options, $_);
			next unless @ret; # stat() failed
			%attrs = (%attrs, %{ $ret[-1] });
			push @okfiles, $_;
			}
		my @sorted = $class->Order($Options, \%Attributes, @okfiles);
		$class->List('.', $Options, 0, 0, @sorted, \%attrs);
		}

	for my $Arg ($class->Order($Options, \%Attributes, @Dirs)) {
		if( ! exists $Options->{'R'} ) {
			print "\n" if !$First;
			$First = 0;
			print "$Arg:\n" if $ArgCount > 0;
			}
		$class->List($Arg, $Options, 1, 0, $class->DirEntries($Options, $Arg));
		}
	}

sub start_time;

__PACKAGE__;

=pod

=encoding utf8

=head1 NAME

ls - list file/directory information

=head1 SYNOPSIS

ls [-1RSacdfiklnrstu] [file ...]

=head1 DESCRIPTION

This program lists information about files and directories.
If it is invoked without file/directory name arguments,
it lists the contents of the current directory.
Otherwise, B<ls> lists information about the files and
information about the contents of the directories (but
see B<-d>).  Furthermore, without any option arguments
B<ls> just lists the names of files and directories.
All files are listed before all directories.
The default sort order is ascending ASCII on filename.

=head2 OPTIONS

The BSD options
'1ACFLRSTWacdfgiklmnopqrstux'
are recognized,
but only '1RSacdfiklnrstu' are implemented:

=over 4

=item -1

List entries 1 per line (default if output is not a tty).

=item -R

Recursively list the contents of all directories, breadth-first.

=item -S

Sort descending by size.

=item -a

List all files (normally files starting with '.' are ignored).

=item -c

Sort by descending last modification time of inode.

=item -d

Do not list directory contents.

=item -f

Do not sort -- list in whatever order files/directories are returned
by the directory read function. This option implies -a.

=item -i

List file inode number.  (Doesn't mean much on non-inode systems.)

=item -k

When used with B<-s>, list file/directory size in 1024-byte blocks.

=item -l

Long format listing of mode -- # of links, owner name, group name,
size in bytes, time of last modification, and name.

=item -n

List numeric uid and gid (default on platforms without getpwuid()).

=item -r

Reverse sorting order.

=item -s

List file/directory size in 512-byte blocks.  (May not mean much
on non-Unix systems.)

=item -t

Sort by descending last modification time.

=item -u

Sort by descending last access time.

=back

=head1 ENVIRONMENT

The working of I<ls> is not influenced by any environment variables.

=head1 BUGS

The file metadata from stat() is used, which may not necessarily mean
much on non-Unix systems.  Specifically, the uid, gid, inode, and
block numbers may be meaningless (or less than meaningful at least).

The B<-l> option does not yet list the major and minor device numbers
for special files, but it does list the value of the 'dev' field as 2
hex 16-bit words. Doing this properly would probably require
filesystem type probing.

=head1 AUTHOR

This Perl implementation of I<ls> was written by Mark Leighton Fisher
of Thomson Consumer Electronics, I<fisherm@tce.com>.

Portions of Stat::lsmode from Mark Jason Dominus have been inlined
into this program uder the perl license. See L<http://www.plover.com/~mjd/perl/lsMode/>.

=head1 COPYRIGHT and LICENSE

This program is free and open software. You may use, modify,
distribute, and sell this program (and any modified variants) in any
way you wish, provided you do not restrict others from doing the same.

=cut


