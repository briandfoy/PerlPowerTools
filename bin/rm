#!/usr/bin/perl

=begin metadata

Name: rm
Description: remove directory entries
Author: Steve Kemp, steve@steve.org.uk
License: gpl

=end metadata

=cut


#############################################################################
#  A simple compatible version of rm( 1 ) written in Perl.
#############################################################################
#
#  Copyright (c) Steve Kemp 1999, skx@tardis.ed.ac.uk
#
#  To do:-
#   Currently the interactive and force options are not handled
#  totally correctly.  According to the man pages for RM the
#  option placement matters, so a -f will override an _earlier_
#  -i, etc.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
##############################################################################

# Packages we use.
use strict;
use Getopt::Std;

# Command line arguments, and other variables.
use vars qw( $opt_i $opt_f $opt_r $opt_R );

getopts('fiPrR') or showUsage();
unless (@ARGV)
{
    warn "$0: missing argument\n";
    exit 1;
}
my $Err = 0;
for my $arg ( @ARGV )
{
    processFile( $arg );
}
exit($Err ? 1 : 0);

#
#  Attempt to process each file / directory named on the command line.
sub processFile()
{
    my  ( $fileName )= @_;

    if (-d $fileName)
    {
	if (!$opt_r && !$opt_R)
	{
	    warn "$0: cannot remove '$fileName': is a directory\n";
	    $Err++;
	    return;
	}
	removeDirectory( $fileName );
    }
    else
    {
	removeFile( $fileName );
    }
}

#
#  Recursively remove a directory
sub removeDirectory( )
{
    my ( $dirName ) = @_;
    my ( $path );

    unless (opendir(DIR, $dirName))
    {
	warn "$0: cannot open '$dirName': $!\n";
	$Err++;
	return;
    }

    foreach (readdir(DIR))
    {
	next if $_ eq '.' || $_ eq '..';
	$path = "$dirName/$_";

	if (-d $path)
	{
	    &removeDirectory($path);
	}
	else
	{
	    removeFile( $path );
	}
    }
    closedir(DIR);

    unless (rmdir $dirName)
    {
	warn "$0: cannot remove directory '$dirName': $!\n";
	$Err++;
    }
}

#
#  Remove a file, asking for confirmation, etc, as
# necessary
sub removeFile( $fileName )
{
    my ( $fileName ) = @_;
    my $reply;

    # If its read only, and we're not forcing, and interactive prompt for deletion
    #
    if ( ( ! -w $fileName ) && ( !$opt_f ) && ( $opt_i ))
    {
	print "$fileName: Read-only ? ";
	$reply = <STDIN>;
	if ( $reply =~ /^[Nn]/ )
	{
	    return;
	}
    }
    elsif ( $opt_i )
    {
	print "$fileName: ? ";
	$reply = <STDIN>;
	if ( $reply =~ /^[Nn]/ )
	{
	    return;
	}
    }

    # If we are forcing the delete first change the files mode to allow writes.
    if ( $opt_f )
    {
	my ( $mode ) = "0777";
	chmod $mode, $fileName;
    }

    # Delete the file.
    unless (unlink $fileName)
    {
	warn "$0: cannot remove '$fileName': $!\n";
	$Err++;
    }
}

#
# Show the useage
sub showUsage()
{
    print << "E-O-F";
Usage: rm [-firR] file ...
     The options are as follows:

     -f    Attempt to remove the files without prompting for confirmation, re-
           gardless of the file's permissions.  If the file does not exist, do
           not display a diagnostic message or modify the exit status to re-
           flect an error.  The -f option overrides any previous -i options.

     -i    Request confirmation before attempting to remove each file, regard-
           less of the file's permissions, or whether or not the standard in-
           put device is a terminal.  The -i option overrides any previous -f
           options.

     -P    This flag is for backwards compatibility and has no effect.

     -R    Attempt to remove the file hierarchy rooted in each file argument.
           The -R option implies the -d option.  If the -i option is speci-
           fied, the user is prompted for confirmation before each directory's
           contents are processed (as well as before the attempt is made to
           remove the directory).  If the user does not respond affirmatively,
           the file hierarchy rooted in that directory is skipped.

     The rm utility removes symbolic links, not the files referenced by the
     links.

     It is an error to attempt to remove the files ``.'' or ``..''.
E-O-F
    exit;
}

=encoding utf8

=head1 NAME

rm - remove directory entries
